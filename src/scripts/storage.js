import { studentService } from "./api/student.service.js";
import { subjectService } from "./api/subject.service.js";
import { resultService } from "./api/result.service.js";
import { dashboardService } from "./api/dashboard.service.js";

// Settings are now fetched from the backend
export async function getSettings() {
  return await dashboardService.getSettings();
}

export async function getAllStudents() {
  return await studentService.getAll();
}

export async function getStudentsByClass(classLevel) {
  return await studentService.getAll({ classLevel });
}

// Backend handles ID generation
export function generateStudentId() {
  // This might not be needed anymore if backend generates ID
  // But if frontend needs to show it before saving, we might need an endpoint
  // For now, let's assume backend returns it after creation
  return "Generated by Server";
}

export async function addStudent(studentData) {
  const newStudent = await studentService.create(studentData);
  return newStudent.studentId;
}

export async function updateStudent(id, studentData) {
  await studentService.update(id, studentData);
}

export async function deleteStudent(id) {
  await studentService.delete(id);
}

export async function getAllSubjects() {
  return await subjectService.getAll();
}

export async function getSubjectsByClass(classLevel) {
  return await subjectService.getAll({ classLevel });
}

export async function getSubjectsForStudent(studentId) {
  try {
    // We need to fetch student first to know their class and department/religion
    // But studentId might be the ID string (e.g. MLC/...), not _id.
    // The backend getById expects _id usually, but let's see student.controller.js
    // Wait, student.controller.js getStudent uses req.params.id which is _id.
    // But the frontend uses studentId (MLC/...).
    // I need to check if I implemented getByStudentId in backend or if I need to search.
    // In student.controller.js: getStudent uses Student.findById(req.params.id).
    // So I need to use _id.
    // But the frontend likely passes the custom studentId string.
    // I might need to update backend to allow searching by studentId or update frontend to use _id.
    // For now, let's assume we can fetch by query param or the frontend has the _id.

    // Actually, let's check how getSubjectsForStudent is used.
    // It's used in editor.js to populate subjects for a student.

    // Let's implement a helper in student service or just use getAll with filters if possible.
    // Or better, fetch the student details using the ID we have.
    // If the ID passed here is the custom ID, we might need a way to lookup.

    // Let's assume for now we can fetch student by _id. If not, we'll fix it.
    // But wait, existing code uses `db.students[studentId]`. `studentId` was the key.
    // In the new system, `_id` is the key.

    const student = await studentService.getById(studentId);
    if (!student) return [];

    const classSubjects = await subjectService.getAll({
      classLevel: student.currentClass,
    });

    return classSubjects.filter((subject) => {
      if (subject.code === "ISLM") {
        return student.religion === "ISLAM";
      }
      if (subject.code === "CRS") {
        return student.religion === "CHRISTIANITY";
      }

      if (subject.department === "GENERAL") {
        return true;
      }

      return subject.department === student.department;
    });
  } catch (error) {
    console.error("Error getting subjects for student:", error);
    return [];
  }
}

export async function getSubjectByCode(code) {
  try {
    return await subjectService.getByCode(code);
  } catch (error) {
    console.error("Error getting subject:", error);
    return null;
  }
}

export async function addSubject(subjectData) {
  try {
    await subjectService.create(subjectData);
    return true;
  } catch (error) {
    alert(error.message);
    return false;
  }
}

export async function updateSubject(code, subjectData) {
  try {
    await subjectService.update(code, subjectData);
    return true;
  } catch (error) {
    alert(error.message);
    return false;
  }
}

export async function deleteSubject(code) {
  await subjectService.delete(code);
}

export async function saveResult(studentId, subjectCode, scores, year, term) {
  // If year or term are not provided, fetch from settings
  if (!year || !term) {
    const settings = await getSettings();
    if (!year) year = settings.currentAcademicYear;
    if (!term) term = settings.currentTerm;
  }

  const resultData = {
    studentId, // This should be _id
    subjectCode,
    academicYear: year,
    term: term,
    weeklyTest: scores.weeklyTest,
    midTerm: scores.midTerm,
    exam: scores.exam,
  };

  await resultService.saveResult(resultData);
}

export async function getStudentResults(studentId, year, term) {
  const settings = await getSettings();
  if (!year) year = settings.currentAcademicYear;
  if (!term) term = settings.currentTerm;

  const results = await resultService.getResults({
    studentId,
    academicYear: year,
    term,
  });

  // The frontend expects a specific structure: { subjects: { code: result } }
  // The backend returns an array of result objects.
  // We need to transform it to match what frontend expects if we want to minimize frontend changes.

  const formattedResults = { subjects: {} };

  if (Array.isArray(results)) {
    results.forEach((result) => {
      formattedResults.subjects[result.subjectCode] = result;
    });
  } else {
    console.error("Expected array of results but got:", results);
  }

  return formattedResults;
}

export async function getResultsByClass(classLevel, subjectCode, year, term) {
  const settings = await getSettings();
  if (!year) year = settings.currentAcademicYear;
  if (!term) term = settings.currentTerm;

  const results = await resultService.getResults({
    classLevel,
    subjectCode,
    academicYear: year,
    term,
  });

  // Transform to map by studentId for easy lookup
  const resultsMap = {};
  results.forEach((result) => {
    // result.studentId is populated, so we use _id
    if (result.studentId && result.studentId._id) {
      resultsMap[result.studentId._id] = result;
    }
  });

  return resultsMap;
}

export async function calculatePositions(classLevel, subjectCode, year, term) {
  const settings = await getSettings();
  if (!year) year = settings.currentAcademicYear;
  if (!term) term = settings.currentTerm;

  await resultService.calculatePositions({
    classLevel,
    subjectCode,
    academicYear: year,
    term,
  });
}
